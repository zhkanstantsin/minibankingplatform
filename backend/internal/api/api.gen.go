// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for Currency.
const (
	EUR Currency = "EUR"
	USD Currency = "USD"
)

// Defines values for TransactionType.
const (
	Deposit    TransactionType = "deposit"
	Exchange   TransactionType = "exchange"
	Transfer   TransactionType = "transfer"
	Withdrawal TransactionType = "withdrawal"
)

// Account defines model for Account.
type Account struct {
	Balance *Money              `json:"balance,omitempty"`
	Id      *openapi_types.UUID `json:"id,omitempty"`
	UserId  *openapi_types.UUID `json:"userId,omitempty"`
}

// AccountMismatch defines model for AccountMismatch.
type AccountMismatch struct {
	AccountBalance *string             `json:"accountBalance,omitempty"`
	AccountId      *openapi_types.UUID `json:"accountId,omitempty"`

	// Currency Supported currencies
	Currency      *Currency `json:"currency,omitempty"`
	Difference    *string   `json:"difference,omitempty"`
	LedgerBalance *string   `json:"ledgerBalance,omitempty"`
}

// AuthResponse defines model for AuthResponse.
type AuthResponse struct {
	Email *openapi_types.Email `json:"email,omitempty"`

	// Token JWT token for authentication
	Token  *string             `json:"token,omitempty"`
	UserId *openapi_types.UUID `json:"userId,omitempty"`
}

// Balance defines model for Balance.
type Balance struct {
	AccountId *openapi_types.UUID `json:"accountId,omitempty"`
	Balance   *Money              `json:"balance,omitempty"`
}

// Currency Supported currencies
type Currency string

// ExchangeCalculation defines model for ExchangeCalculation.
type ExchangeCalculation struct {
	ExchangeRate *struct {
		// Rate Exchange rate value
		Rate *string `json:"rate,omitempty"`

		// SourceCurrency Supported currencies
		SourceCurrency *Currency `json:"sourceCurrency,omitempty"`

		// TargetCurrency Supported currencies
		TargetCurrency *Currency `json:"targetCurrency,omitempty"`
	} `json:"exchangeRate,omitempty"`
	SourceAmount *Money `json:"sourceAmount,omitempty"`
	TargetAmount *Money `json:"targetAmount,omitempty"`
}

// ExchangeDetails defines model for ExchangeDetails.
type ExchangeDetails struct {
	ExchangeRate    *string             `json:"exchangeRate,omitempty"`
	Id              *openapi_types.UUID `json:"id,omitempty"`
	SourceAccountId *openapi_types.UUID `json:"sourceAccountId,omitempty"`
	SourceAmount    *Money              `json:"sourceAmount,omitempty"`
	TargetAccountId *openapi_types.UUID `json:"targetAccountId,omitempty"`
	TargetAmount    *Money              `json:"targetAmount,omitempty"`
}

// ExchangeRequest defines model for ExchangeRequest.
type ExchangeRequest struct {
	// Amount Amount to exchange from source currency
	Amount string `json:"amount" validate:"required"`

	// SourceAccountId Source account UUID (currency to exchange from)
	SourceAccountId openapi_types.UUID `json:"sourceAccountId" validate:"required,uuid"`

	// TargetAccountId Target account UUID (currency to exchange to)
	TargetAccountId openapi_types.UUID `json:"targetAccountId" validate:"required,uuid"`
}

// ExchangeResponse defines model for ExchangeResponse.
type ExchangeResponse struct {
	// ExchangeRate Exchange rate used (e.g., "0.92" for USD to EUR)
	ExchangeRate    *string             `json:"exchangeRate,omitempty"`
	SourceAccountId *openapi_types.UUID `json:"sourceAccountId,omitempty"`
	SourceAmount    *Money              `json:"sourceAmount,omitempty"`
	TargetAccountId *openapi_types.UUID `json:"targetAccountId,omitempty"`
	TargetAmount    *Money              `json:"targetAmount,omitempty"`
	Timestamp       *time.Time          `json:"timestamp,omitempty"`
	TransactionId   *openapi_types.UUID `json:"transactionId,omitempty"`
}

// LedgerCurrencyStatus defines model for LedgerCurrencyStatus.
type LedgerCurrencyStatus struct {
	// Currency Supported currencies
	Currency *Currency `json:"currency,omitempty"`

	// IsBalanced True if totalSum is zero
	IsBalanced *bool `json:"isBalanced,omitempty"`

	// TotalSum Sum of all ledger entries for this currency
	TotalSum *string `json:"totalSum,omitempty"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	Email    openapi_types.Email `json:"email" validate:"required,email"`
	Password string              `json:"password" validate:"required"`
}

// Money defines model for Money.
type Money struct {
	// Amount Decimal amount with 2 decimal places
	Amount *string `json:"amount,omitempty"`

	// Currency Supported currencies
	Currency *Currency `json:"currency,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Limit Items per page
	Limit *int `json:"limit,omitempty"`

	// Page Current page number
	Page *int `json:"page,omitempty"`

	// Total Total number of items
	Total *int `json:"total,omitempty"`

	// TotalPages Total number of pages
	TotalPages *int `json:"totalPages,omitempty"`
}

// ProblemDetails RFC 7807 Problem Details for HTTP APIs
type ProblemDetails struct {
	// Detail A human-readable explanation specific to this occurrence
	// of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of
	// the problem. It may or may not yield further information
	// if dereferenced.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code generated by the origin server for this
	// occurrence of the problem.
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type.
	// It SHOULD NOT change from occurrence to occurrence of the problem.
	Title string `json:"title"`

	// Type A URI reference that identifies the problem type.
	// This specification encourages that, when dereferenced,
	// it provide human-readable documentation for the problem type.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReconciliationReport defines model for ReconciliationReport.
type ReconciliationReport struct {
	AccountMismatches *[]AccountMismatch `json:"accountMismatches,omitempty"`

	// IsConsistent True if all checks passed
	IsConsistent         *bool                   `json:"isConsistent,omitempty"`
	LedgerBalances       *[]LedgerCurrencyStatus `json:"ledgerBalances,omitempty"`
	Timestamp            *time.Time              `json:"timestamp,omitempty"`
	TotalAccountsChecked *int                    `json:"totalAccountsChecked,omitempty"`
}

// RegisterRequest defines model for RegisterRequest.
type RegisterRequest struct {
	Email    openapi_types.Email `json:"email" validate:"required,email"`
	Password string              `json:"password" validate:"required,min=8"`
}

// Transaction defines model for Transaction.
type Transaction struct {
	AccountId       *openapi_types.UUID `json:"accountId,omitempty"`
	ExchangeDetails *ExchangeDetails    `json:"exchangeDetails"`
	Id              *openapi_types.UUID `json:"id,omitempty"`
	Timestamp       *time.Time          `json:"timestamp,omitempty"`
	TransferDetails *TransferDetails    `json:"transferDetails"`

	// Type Type of transaction
	Type *TransactionType `json:"type,omitempty"`
}

// TransactionType Type of transaction
type TransactionType string

// TransactionsResponse defines model for TransactionsResponse.
type TransactionsResponse struct {
	Pagination   *Pagination    `json:"pagination,omitempty"`
	Transactions *[]Transaction `json:"transactions,omitempty"`
}

// TransferDetails defines model for TransferDetails.
type TransferDetails struct {
	Amount             *Money              `json:"amount,omitempty"`
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	RecipientAccountId *openapi_types.UUID `json:"recipientAccountId,omitempty"`
}

// TransferRequest defines model for TransferRequest.
type TransferRequest struct {
	// Amount Amount to transfer (positive, 2 decimal places)
	Amount string `json:"amount" validate:"required"`

	// Currency Supported currencies
	Currency Currency `json:"currency"`

	// FromAccountId Source account UUID (must belong to authenticated user)
	FromAccountId openapi_types.UUID `json:"fromAccountId" validate:"required,uuid"`

	// ToAccountId Destination account UUID
	ToAccountId openapi_types.UUID `json:"toAccountId" validate:"required,uuid"`
}

// TransferResponse defines model for TransferResponse.
type TransferResponse struct {
	Amount        *Money              `json:"amount,omitempty"`
	FromAccountId *openapi_types.UUID `json:"fromAccountId,omitempty"`
	Timestamp     *time.Time          `json:"timestamp,omitempty"`
	ToAccountId   *openapi_types.UUID `json:"toAccountId,omitempty"`
	TransactionId *openapi_types.UUID `json:"transactionId,omitempty"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	Email  *openapi_types.Email `json:"email,omitempty"`
	UserId *openapi_types.UUID  `json:"userId,omitempty"`
}

// ListTransactionsParams defines parameters for ListTransactions.
type ListTransactionsParams struct {
	// Type Filter by transaction type
	Type *TransactionType `form:"type,omitempty" json:"type,omitempty"`

	// Page Page number (1-based)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CalculateExchangeParams defines parameters for CalculateExchange.
type CalculateExchangeParams struct {
	// Amount Amount to exchange
	Amount string `form:"amount" json:"amount"`

	// SourceCurrency Source currency
	SourceCurrency Currency `form:"sourceCurrency" json:"sourceCurrency"`

	// TargetCurrency Target currency
	TargetCurrency Currency `form:"targetCurrency" json:"targetCurrency"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginRequest

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody = RegisterRequest

// ExchangeJSONRequestBody defines body for Exchange for application/json ContentType.
type ExchangeJSONRequestBody = ExchangeRequest

// TransferJSONRequestBody defines body for Transfer for application/json ContentType.
type TransferJSONRequestBody = TransferRequest

// Getter for additional properties for ProblemDetails. Returns the specified
// element and whether it was found
func (a ProblemDetails) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProblemDetails
func (a *ProblemDetails) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProblemDetails to handle AdditionalProperties
func (a *ProblemDetails) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["instance"]; found {
		err = json.Unmarshal(raw, &a.Instance)
		if err != nil {
			return fmt.Errorf("error reading 'instance': %w", err)
		}
		delete(object, "instance")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProblemDetails to handle AdditionalProperties
func (a ProblemDetails) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Detail != nil {
		object["detail"], err = json.Marshal(a.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if a.Instance != nil {
		object["instance"], err = json.Marshal(a.Instance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'instance': %w", err)
		}
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List user's accounts
	// (GET /accounts)
	ListAccounts(w http.ResponseWriter, r *http.Request)
	// Get account balance
	// (GET /accounts/{accountId}/balance)
	GetAccountBalance(w http.ResponseWriter, r *http.Request, accountId openapi_types.UUID)
	// Authenticate user
	// (POST /auth/login)
	Login(w http.ResponseWriter, r *http.Request)
	// Get current user info
	// (GET /auth/me)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
	// Register a new user
	// (POST /auth/register)
	Register(w http.ResponseWriter, r *http.Request)
	// Reconciliation report
	// (GET /system/reconcile)
	Reconcile(w http.ResponseWriter, r *http.Request)
	// List transactions
	// (GET /transactions)
	ListTransactions(w http.ResponseWriter, r *http.Request, params ListTransactionsParams)
	// Exchange currency within user's accounts
	// (POST /transactions/exchange)
	Exchange(w http.ResponseWriter, r *http.Request)
	// Calculate exchange amount
	// (GET /transactions/exchange/calculate)
	CalculateExchange(w http.ResponseWriter, r *http.Request, params CalculateExchangeParams)
	// Transfer money between users
	// (POST /transactions/transfer)
	Transfer(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List user's accounts
// (GET /accounts)
func (_ Unimplemented) ListAccounts(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get account balance
// (GET /accounts/{accountId}/balance)
func (_ Unimplemented) GetAccountBalance(w http.ResponseWriter, r *http.Request, accountId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Authenticate user
// (POST /auth/login)
func (_ Unimplemented) Login(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current user info
// (GET /auth/me)
func (_ Unimplemented) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register a new user
// (POST /auth/register)
func (_ Unimplemented) Register(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Reconciliation report
// (GET /system/reconcile)
func (_ Unimplemented) Reconcile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List transactions
// (GET /transactions)
func (_ Unimplemented) ListTransactions(w http.ResponseWriter, r *http.Request, params ListTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Exchange currency within user's accounts
// (POST /transactions/exchange)
func (_ Unimplemented) Exchange(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Calculate exchange amount
// (GET /transactions/exchange/calculate)
func (_ Unimplemented) CalculateExchange(w http.ResponseWriter, r *http.Request, params CalculateExchangeParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Transfer money between users
// (POST /transactions/transfer)
func (_ Unimplemented) Transfer(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListAccounts operation middleware
func (siw *ServerInterfaceWrapper) ListAccounts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAccounts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAccountBalance operation middleware
func (siw *ServerInterfaceWrapper) GetAccountBalance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", chi.URLParam(r, "accountId"), &accountId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccountBalance(w, r, accountId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Register operation middleware
func (siw *ServerInterfaceWrapper) Register(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Register(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Reconcile operation middleware
func (siw *ServerInterfaceWrapper) Reconcile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Reconcile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListTransactions operation middleware
func (siw *ServerInterfaceWrapper) ListTransactions(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTransactionsParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTransactions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Exchange operation middleware
func (siw *ServerInterfaceWrapper) Exchange(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Exchange(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CalculateExchange operation middleware
func (siw *ServerInterfaceWrapper) CalculateExchange(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CalculateExchangeParams

	// ------------- Required query parameter "amount" -------------

	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "amount"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "amount", Err: err})
		return
	}

	// ------------- Required query parameter "sourceCurrency" -------------

	if paramValue := r.URL.Query().Get("sourceCurrency"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "sourceCurrency"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "sourceCurrency", r.URL.Query(), &params.SourceCurrency)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sourceCurrency", Err: err})
		return
	}

	// ------------- Required query parameter "targetCurrency" -------------

	if paramValue := r.URL.Query().Get("targetCurrency"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "targetCurrency"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "targetCurrency", r.URL.Query(), &params.TargetCurrency)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "targetCurrency", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CalculateExchange(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Transfer operation middleware
func (siw *ServerInterfaceWrapper) Transfer(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Transfer(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/accounts", wrapper.ListAccounts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/accounts/{accountId}/balance", wrapper.GetAccountBalance)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.Login)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/me", wrapper.GetCurrentUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/register", wrapper.Register)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/reconcile", wrapper.Reconcile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/transactions", wrapper.ListTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/transactions/exchange", wrapper.Exchange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/transactions/exchange/calculate", wrapper.CalculateExchange)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/transactions/transfer", wrapper.Transfer)
	})

	return r
}

type ListAccountsRequestObject struct {
}

type ListAccountsResponseObject interface {
	VisitListAccountsResponse(w http.ResponseWriter) error
}

type ListAccounts200JSONResponse []Account

func (response ListAccounts200JSONResponse) VisitListAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListAccounts401ApplicationProblemPlusJSONResponse ProblemDetails

func (response ListAccounts401ApplicationProblemPlusJSONResponse) VisitListAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetAccountBalanceRequestObject struct {
	AccountId openapi_types.UUID `json:"accountId"`
}

type GetAccountBalanceResponseObject interface {
	VisitGetAccountBalanceResponse(w http.ResponseWriter) error
}

type GetAccountBalance200JSONResponse Balance

func (response GetAccountBalance200JSONResponse) VisitGetAccountBalanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAccountBalance401ApplicationProblemPlusJSONResponse ProblemDetails

func (response GetAccountBalance401ApplicationProblemPlusJSONResponse) VisitGetAccountBalanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetAccountBalance403ApplicationProblemPlusJSONResponse ProblemDetails

func (response GetAccountBalance403ApplicationProblemPlusJSONResponse) VisitGetAccountBalanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetAccountBalance404ApplicationProblemPlusJSONResponse ProblemDetails

func (response GetAccountBalance404ApplicationProblemPlusJSONResponse) VisitGetAccountBalanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type LoginRequestObject struct {
	Body *LoginJSONRequestBody
}

type LoginResponseObject interface {
	VisitLoginResponse(w http.ResponseWriter) error
}

type Login200JSONResponse AuthResponse

func (response Login200JSONResponse) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Login400ApplicationProblemPlusJSONResponse ProblemDetails

func (response Login400ApplicationProblemPlusJSONResponse) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Login401ApplicationProblemPlusJSONResponse ProblemDetails

func (response Login401ApplicationProblemPlusJSONResponse) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetCurrentUserRequestObject struct {
}

type GetCurrentUserResponseObject interface {
	VisitGetCurrentUserResponse(w http.ResponseWriter) error
}

type GetCurrentUser200JSONResponse UserInfo

func (response GetCurrentUser200JSONResponse) VisitGetCurrentUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetCurrentUser401ApplicationProblemPlusJSONResponse ProblemDetails

func (response GetCurrentUser401ApplicationProblemPlusJSONResponse) VisitGetCurrentUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RegisterRequestObject struct {
	Body *RegisterJSONRequestBody
}

type RegisterResponseObject interface {
	VisitRegisterResponse(w http.ResponseWriter) error
}

type Register201JSONResponse AuthResponse

func (response Register201JSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type Register400ApplicationProblemPlusJSONResponse ProblemDetails

func (response Register400ApplicationProblemPlusJSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Register409ApplicationProblemPlusJSONResponse ProblemDetails

func (response Register409ApplicationProblemPlusJSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type ReconcileRequestObject struct {
}

type ReconcileResponseObject interface {
	VisitReconcileResponse(w http.ResponseWriter) error
}

type Reconcile200JSONResponse ReconciliationReport

func (response Reconcile200JSONResponse) VisitReconcileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Reconcile401ApplicationProblemPlusJSONResponse ProblemDetails

func (response Reconcile401ApplicationProblemPlusJSONResponse) VisitReconcileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ListTransactionsRequestObject struct {
	Params ListTransactionsParams
}

type ListTransactionsResponseObject interface {
	VisitListTransactionsResponse(w http.ResponseWriter) error
}

type ListTransactions200JSONResponse TransactionsResponse

func (response ListTransactions200JSONResponse) VisitListTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListTransactions401ApplicationProblemPlusJSONResponse ProblemDetails

func (response ListTransactions401ApplicationProblemPlusJSONResponse) VisitListTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ExchangeRequestObject struct {
	Body *ExchangeJSONRequestBody
}

type ExchangeResponseObject interface {
	VisitExchangeResponse(w http.ResponseWriter) error
}

type Exchange200JSONResponse ExchangeResponse

func (response Exchange200JSONResponse) VisitExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Exchange400ApplicationProblemPlusJSONResponse ProblemDetails

func (response Exchange400ApplicationProblemPlusJSONResponse) VisitExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Exchange401ApplicationProblemPlusJSONResponse ProblemDetails

func (response Exchange401ApplicationProblemPlusJSONResponse) VisitExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type Exchange404ApplicationProblemPlusJSONResponse ProblemDetails

func (response Exchange404ApplicationProblemPlusJSONResponse) VisitExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CalculateExchangeRequestObject struct {
	Params CalculateExchangeParams
}

type CalculateExchangeResponseObject interface {
	VisitCalculateExchangeResponse(w http.ResponseWriter) error
}

type CalculateExchange200JSONResponse ExchangeCalculation

func (response CalculateExchange200JSONResponse) VisitCalculateExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CalculateExchange400ApplicationProblemPlusJSONResponse ProblemDetails

func (response CalculateExchange400ApplicationProblemPlusJSONResponse) VisitCalculateExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CalculateExchange401ApplicationProblemPlusJSONResponse ProblemDetails

func (response CalculateExchange401ApplicationProblemPlusJSONResponse) VisitCalculateExchangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type TransferRequestObject struct {
	Body *TransferJSONRequestBody
}

type TransferResponseObject interface {
	VisitTransferResponse(w http.ResponseWriter) error
}

type Transfer200JSONResponse TransferResponse

func (response Transfer200JSONResponse) VisitTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Transfer400ApplicationProblemPlusJSONResponse ProblemDetails

func (response Transfer400ApplicationProblemPlusJSONResponse) VisitTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Transfer401ApplicationProblemPlusJSONResponse ProblemDetails

func (response Transfer401ApplicationProblemPlusJSONResponse) VisitTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type Transfer404ApplicationProblemPlusJSONResponse ProblemDetails

func (response Transfer404ApplicationProblemPlusJSONResponse) VisitTransferResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// List user's accounts
	// (GET /accounts)
	ListAccounts(ctx context.Context, request ListAccountsRequestObject) (ListAccountsResponseObject, error)
	// Get account balance
	// (GET /accounts/{accountId}/balance)
	GetAccountBalance(ctx context.Context, request GetAccountBalanceRequestObject) (GetAccountBalanceResponseObject, error)
	// Authenticate user
	// (POST /auth/login)
	Login(ctx context.Context, request LoginRequestObject) (LoginResponseObject, error)
	// Get current user info
	// (GET /auth/me)
	GetCurrentUser(ctx context.Context, request GetCurrentUserRequestObject) (GetCurrentUserResponseObject, error)
	// Register a new user
	// (POST /auth/register)
	Register(ctx context.Context, request RegisterRequestObject) (RegisterResponseObject, error)
	// Reconciliation report
	// (GET /system/reconcile)
	Reconcile(ctx context.Context, request ReconcileRequestObject) (ReconcileResponseObject, error)
	// List transactions
	// (GET /transactions)
	ListTransactions(ctx context.Context, request ListTransactionsRequestObject) (ListTransactionsResponseObject, error)
	// Exchange currency within user's accounts
	// (POST /transactions/exchange)
	Exchange(ctx context.Context, request ExchangeRequestObject) (ExchangeResponseObject, error)
	// Calculate exchange amount
	// (GET /transactions/exchange/calculate)
	CalculateExchange(ctx context.Context, request CalculateExchangeRequestObject) (CalculateExchangeResponseObject, error)
	// Transfer money between users
	// (POST /transactions/transfer)
	Transfer(ctx context.Context, request TransferRequestObject) (TransferResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ListAccounts operation middleware
func (sh *strictHandler) ListAccounts(w http.ResponseWriter, r *http.Request) {
	var request ListAccountsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListAccounts(ctx, request.(ListAccountsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListAccounts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListAccountsResponseObject); ok {
		if err := validResponse.VisitListAccountsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAccountBalance operation middleware
func (sh *strictHandler) GetAccountBalance(w http.ResponseWriter, r *http.Request, accountId openapi_types.UUID) {
	var request GetAccountBalanceRequestObject

	request.AccountId = accountId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAccountBalance(ctx, request.(GetAccountBalanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAccountBalance")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAccountBalanceResponseObject); ok {
		if err := validResponse.VisitGetAccountBalanceResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Login operation middleware
func (sh *strictHandler) Login(w http.ResponseWriter, r *http.Request) {
	var request LoginRequestObject

	var body LoginJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Login(ctx, request.(LoginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Login")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LoginResponseObject); ok {
		if err := validResponse.VisitLoginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCurrentUser operation middleware
func (sh *strictHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	var request GetCurrentUserRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCurrentUser(ctx, request.(GetCurrentUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCurrentUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCurrentUserResponseObject); ok {
		if err := validResponse.VisitGetCurrentUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Register operation middleware
func (sh *strictHandler) Register(w http.ResponseWriter, r *http.Request) {
	var request RegisterRequestObject

	var body RegisterJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Register(ctx, request.(RegisterRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Register")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RegisterResponseObject); ok {
		if err := validResponse.VisitRegisterResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Reconcile operation middleware
func (sh *strictHandler) Reconcile(w http.ResponseWriter, r *http.Request) {
	var request ReconcileRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Reconcile(ctx, request.(ReconcileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Reconcile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ReconcileResponseObject); ok {
		if err := validResponse.VisitReconcileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListTransactions operation middleware
func (sh *strictHandler) ListTransactions(w http.ResponseWriter, r *http.Request, params ListTransactionsParams) {
	var request ListTransactionsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListTransactions(ctx, request.(ListTransactionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListTransactions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListTransactionsResponseObject); ok {
		if err := validResponse.VisitListTransactionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Exchange operation middleware
func (sh *strictHandler) Exchange(w http.ResponseWriter, r *http.Request) {
	var request ExchangeRequestObject

	var body ExchangeJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Exchange(ctx, request.(ExchangeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Exchange")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ExchangeResponseObject); ok {
		if err := validResponse.VisitExchangeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CalculateExchange operation middleware
func (sh *strictHandler) CalculateExchange(w http.ResponseWriter, r *http.Request, params CalculateExchangeParams) {
	var request CalculateExchangeRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CalculateExchange(ctx, request.(CalculateExchangeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CalculateExchange")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CalculateExchangeResponseObject); ok {
		if err := validResponse.VisitCalculateExchangeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Transfer operation middleware
func (sh *strictHandler) Transfer(w http.ResponseWriter, r *http.Request) {
	var request TransferRequestObject

	var body TransferJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Transfer(ctx, request.(TransferRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Transfer")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(TransferResponseObject); ok {
		if err := validResponse.VisitTransferResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
